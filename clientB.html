<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="clientB.css">
    <title>WebRTC - Client B</title>
</head>
<body>
    <video id="remoteVideo" autoplay playsinline style="width: 100vw; height: 100vh;"></video>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>
    <button id="firedroite" onclick="">Fire</button>
    <button id="firegauche" onclick="">Fire</button>
    <button id="avance" onclick="">▲</button>
    <button id="recule" onclick="">▼</button>
    <button id="droite" onclick="">▶</button>
    <button id="gauche" onclick="">◀</button>
    <button id="reconnection" onclick="connectWebSocket()">Reconnecte</button>
    <button id="arret" onclick="">Arret</button>
    <script>
        const remoteVideo = document.getElementById('remoteVideo');
        const peerConnection = new RTCPeerConnection();
        let socket;

        function connectWebSocket() {
            socket = new WebSocket('wss://nameless-caverns-19262-2b731442c0a5.herokuapp.com'); // Remplacez par l'URL de votre serveur WebSocket

            socket.onopen = () => {
                console.log('Connecté au serveur WebSocket');
            };

            socket.onmessage = event => {
                if (event.data instanceof Blob) {
                    const reader = new FileReader();
                    reader.onload = function() {
                        try {
                            const message = JSON.parse(reader.result);
                            handleMessage(message);
                        } catch (error) {
                            console.error('Erreur lors du traitement du message:', error);
                        }
                    };
                    reader.readAsText(event.data);
                } else if (typeof event.data === 'string') {
                    try {
                        const message = JSON.parse(event.data);
                        handleMessage(message);
                    } catch (error) {
                        console.error('Erreur lors du traitement du message:', error);
                    }
                } else {
                    console.error('Données reçues non-JSON:', event.data);
                }
            };

            socket.onerror = error => {
                console.error('Erreur WebSocket:', error);
            };

            socket.onclose = event => {
                console.log(`Déconnexion du serveur WebSocket: Code ${event.code}, Raison: ${event.reason}`);
                setTimeout(connectWebSocket, 1000);
            };
        }

        function handleMessage(message) {
            console.log('Message reçu:', message);

            if (message.type === 'offer') {
                peerConnection.setRemoteDescription(new RTCSessionDescription(message.data))
                    .then(() => peerConnection.createAnswer())
                    .then(answer => peerConnection.setLocalDescription(answer))
                    .then(() => {
                        socket.send(JSON.stringify({ type: 'answer', data: peerConnection.localDescription }));
                    })
                    .catch(error => {
                        console.error('Erreur lors de la réponse:', error);
                    });
            } else if (message.type === 'candidate') {
                peerConnection.addIceCandidate(new RTCIceCandidate(message.data))
                    .catch(error => {
                        console.error('Erreur lors de l\'ajout du candidat ICE:', error);
                    });
            }
        }

        connectWebSocket();

        peerConnection.ontrack = event => {
            console.log('Track reçue:', event);
            console.log('Streams reçues:', event.streams);
            console.log('Streams reçues:', event.streams[0]);
            if (event.streams && event.streams[0]) {
                remoteVideo.srcObject = event.streams[0];
            } else {
                console.error('Aucun flux vidéo trouvé dans les données reçues.');
            }
        };

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                socket.send(JSON.stringify({ type: 'candidate', data: event.candidate }));
            }
        };

        const joystickContainer = document.getElementById('joystick-container');
        const joystick = document.getElementById('joystick');

        let joystickCenterX = joystickContainer.offsetWidth / 2;
        let joystickCenterY = joystickContainer.offsetHeight / 2;
        let joystickRadius = joystickContainer.offsetWidth / 2;

        joystickContainer.addEventListener('touchstart', handleStart, false);
        joystickContainer.addEventListener('touchmove', handleMove, false);
        joystickContainer.addEventListener('touchend', handleEnd, false);

        function handleStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            moveJoystick(touch.clientX, touch.clientY);
        }

        function handleMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            moveJoystick(touch.clientX, touch.clientY);
        }

        function handleEnd(event) {
            event.preventDefault();
            resetJoystick();
        }

        function moveJoystick(clientX, clientY) {
            const rect = joystickContainer.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const deltaX = x - joystickCenterX;
            const deltaY = y - joystickCenterY;

            const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), joystickRadius);
            const angle = Math.atan2(deltaY, deltaX);

            const limitedX = joystickCenterX + distance * Math.cos(angle);
            const limitedY = joystickCenterY + distance * Math.sin(angle);

            joystick.style.left = `${limitedX}px`;
            joystick.style.top = `${limitedY}px`;

            const angleInDegrees = (angle * (180 / Math.PI) + 360) % 360
            const degree = Math.round(angleInDegrees)
        }

        function resetJoystick() {
            joystick.style.left = '50%';
            joystick.style.top = '50%';
        }
    </script>
</body>
</html>
